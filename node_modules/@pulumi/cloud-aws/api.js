"use strict";
// Copyright 2016-2018, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
const aws = require("@pulumi/aws");
const awsx = require("@pulumi/awsx");
const pulumi = require("@pulumi/pulumi");
const errors_1 = require("@pulumi/pulumi/errors");
const function_1 = require("./function");
const utils_1 = require("./utils");
// Helper to test whether the Domain is a cloud.Domain or an AWS-specific Domain.
function isCloudDomain(domain) {
    return domain.certificateBody !== undefined;
}
class API {
    constructor(name) {
        this.name = name;
        this.staticRoutes = [];
        this.proxyRoutes = [];
        this.routes = [];
        this.customDomains = [];
    }
    static(path, localPath, options) {
        if (!path.startsWith("/")) {
            path = "/" + path;
        }
        this.staticRoutes.push({ path, localPath, options: options || {} });
    }
    proxy(path, target) {
        if (!path.startsWith("/")) {
            path = "/" + path;
        }
        this.proxyRoutes.push({ path, target });
    }
    route(method, path, ...handlers) {
        if (!path.startsWith("/")) {
            path = "/" + path;
        }
        this.routes.push({ method: method, path: path, handlers: handlers });
    }
    get(path, ...handlers) {
        this.route("GET", path, ...handlers);
    }
    put(path, ...handlers) {
        this.route("PUT", path, ...handlers);
    }
    post(path, ...handlers) {
        this.route("POST", path, ...handlers);
    }
    delete(path, ...handlers) {
        this.route("DELETE", path, ...handlers);
    }
    options(path, ...handlers) {
        this.route("OPTIONS", path, ...handlers);
    }
    all(path, ...handlers) {
        this.route("ANY", path, ...handlers);
    }
    attachCustomDomain(domain) {
        this.customDomains.push(domain);
    }
    publish() {
        if (this.deployment) {
            throw new errors_1.RunError("This endpoint is already published and cannot be re-published.");
        }
        // Create a unique name prefix that includes the name plus all the registered routes.
        this.deployment = new HttpDeployment(this.name, this.staticRoutes, this.proxyRoutes, this.routes, this.customDomains);
        return this.deployment;
    }
}
exports.API = API;
// HttpDeployment actually performs a deployment of a set of HTTP API Gateway resources.
class HttpDeployment extends pulumi.ComponentResource {
    constructor(name, staticRoutes, proxyRoutes, routes, customDomains, opts) {
        super("cloud:http:API", name, {}, opts);
        this.staticRoutes = staticRoutes;
        this.proxyRoutes = proxyRoutes;
        this.routes = routes;
        this.api = new awsx.apigateway.API(name, {
            routes: [
                ...staticRoutes.map(convertStaticRoute),
                ...proxyRoutes.map(r => convertProxyRoute(name, this, r)),
                ...routes.map(r => convertRoute(name, r, { parent: this })),
            ],
        }, { parent: this });
        // If there are any custom domains, attach them now.
        const awsDomains = HttpDeployment.registerCustomDomains(this, name, this.api.restAPI, customDomains);
        // Finally, manufacture a URL and set it as an output property.
        this.url = this.api.url;
        this.customDomainNames = awsDomains.map(awsDomain => awsDomain.cloudfrontDomainName);
        this.customDomains = awsDomains;
        this.registerOutputs({
            api: this.api,
            url: this.url,
            staticRoutes: staticRoutes,
            proxyRoutes: proxyRoutes,
            routes: routes,
            customDomainNames: this.customDomainNames,
            customDomains: this.customDomainNames,
        });
    }
    static registerCustomDomains(parent, apiName, api, domains) {
        const awsDomains = [];
        for (const domain of domains) {
            // Ensure this pair of api-domain name doesn't conflict with anything else.  i.e. there
            // may be another http endpoint that registers a custom domain with a different data.
            // We don't want to collide with that. hash the name to ensure this urn doesn't get too
            // long.
            const domainNameHash = utils_1.sha1hash(domain.domainName);
            const apiNameAndHash = `${apiName}-${domainNameHash}`;
            let domainArgs;
            if (isCloudDomain(domain)) {
                domainArgs = {
                    domainName: domain.domainName,
                    certificateName: domain.domainName,
                    certificateBody: domain.certificateBody,
                    certificatePrivateKey: domain.certificatePrivateKey,
                    certificateChain: domain.certificateChain,
                };
            }
            else {
                domainArgs = {
                    domainName: domain.domainName,
                    certificateArn: domain.certificateArn,
                };
            }
            const awsDomain = new aws.apigateway.DomainName(apiNameAndHash, domainArgs, { parent });
            const basePathMapping = new aws.apigateway.BasePathMapping(apiNameAndHash, {
                restApi: api,
                stageName: stageName,
                domainName: awsDomain.domainName,
            }, { parent });
            awsDomains.push(awsDomain);
        }
        return awsDomains;
    }
}
exports.HttpDeployment = HttpDeployment;
function convertStaticRoute(route) {
    const options = route.options || {};
    return {
        path: route.path,
        localPath: route.localPath,
        contentType: options.contentType,
        index: options.index,
    };
}
function convertProxyRoute(name, api, route) {
    return {
        path: route.path,
        target: convertProxyRouteTarget(name, api, route),
    };
}
function convertProxyRouteTarget(name, api, route) {
    const target = route.target;
    if (typeof target === "string") {
        let result = target;
        // ensure there is a trailing `/`
        if (!result.endsWith("/")) {
            result += "/";
        }
        return { uri: result, type: "http_proxy", connectionId: undefined, connectionType: undefined };
    }
    const targetArn = target.apply(ep => {
        const endpoint = ep;
        if (!endpoint.loadBalancer) {
            throw new pulumi.ResourceError("AWS endpoint proxy requires an AWS Endpoint", api);
        }
        return endpoint.loadBalancer.loadBalancerType.apply(loadBalancerType => {
            if (loadBalancerType === "application") {
                // We can only support proxying to an Endpoint if it is backed by an
                // NLB, which will only be the case for cloud.Service ports exposed as
                // type "tcp".
                throw new pulumi.ResourceError("AWS endpoint proxy requires an Endpoint on a service port of type 'tcp'", api);
            }
            return endpoint.loadBalancer.arn;
        });
    });
    const vpcLink = new aws.apigateway.VpcLink(name + utils_1.sha1hash(route.path), {
        targetArn: targetArn,
    }, { parent: api });
    return {
        uri: pulumi.interpolate `http://${target.hostname}:${target.port}/`,
        type: "http_proxy",
        connectionType: "VPC_LINK",
        connectionId: vpcLink.id,
    };
}
function convertRoute(name, route, opts) {
    return {
        method: route.method,
        path: route.path,
        eventHandler: convertHandlers(name, route, opts),
    };
}
function convertHandlers(name, route, opts) {
    const handlers = route.handlers;
    const callback = (ev, ctx, cb) => {
        let body;
        if (ev.body !== null) {
            if (ev.isBase64Encoded) {
                body = Buffer.from(ev.body, "base64");
            }
            else {
                body = Buffer.from(ev.body, "utf8");
            }
        }
        else {
            body = Buffer.from([]);
        }
        ctx.callbackWaitsForEmptyEventLoop = false;
        const [req, res] = apiGatewayToRequestResponse(ev, body, cb);
        let i = 0;
        const next = () => {
            const nextHandler = handlers[i++];
            if (nextHandler !== undefined) {
                nextHandler(req, res, next);
            }
        };
        next();
    };
    const routeName = name + utils_1.sha1hash(route.method + ":" + route.path);
    // Create the CallbackFunction in the cloud layer as opposed to just passing 'callback' as-is to
    // apigateway.x.API to do it. This ensures that the right configuration values are used that
    // will appropriately respect user settings around things like codepaths/policies etc.
    const callbackFunction = function_1.createCallbackFunction(routeName, callback, /*isFactoryFunction:*/ false, opts);
    return callbackFunction;
}
const stageName = "stage";
function apiGatewayToRequestResponse(ev, body, cb) {
    const response = {
        statusCode: 200,
        headers: {},
        body: Buffer.from([]),
    };
    const headers = {};
    const rawHeaders = [];
    // Lowercase all header names to align with Node.js HTTP request behaviour,
    // and create the `rawHeaders` array to maintain access to raw header data.
    if (ev.headers) {
        for (const name of Object.keys(ev.headers)) {
            headers[name.toLowerCase()] = ev.headers[name];
            rawHeaders.push(name);
            rawHeaders.push(ev.headers[name]);
        }
    }
    // Always add `content-length` header, as this is stripped by API Gateway
    headers["content-length"] = body.length.toString();
    const req = {
        headers: headers,
        rawHeaders: rawHeaders,
        body: body,
        method: ev.httpMethod,
        params: ev.pathParameters || {},
        query: ev.queryStringParameters || {},
        path: ev.path,
        baseUrl: "/" + stageName,
        hostname: headers["host"],
        protocol: headers["x-forwarded-proto"],
    };
    const res = {
        locals: {},
        status: (code) => {
            response.statusCode = code;
            return res;
        },
        getHeader: (name) => {
            return response.headers[name];
        },
        setHeader: (name, value) => {
            response.headers[name] = value;
            return res;
        },
        write: (data, encoding) => {
            if (encoding === undefined) {
                encoding = "utf8";
            }
            if (typeof data === "string") {
                data = Buffer.from(data, encoding);
            }
            response.body = Buffer.concat([response.body, data]);
            return res;
        },
        end: (data, encoding) => {
            if (data !== undefined) {
                res.write(data, encoding);
            }
            cb(null, {
                statusCode: response.statusCode,
                headers: response.headers,
                isBase64Encoded: true,
                body: response.body.toString("base64"),
            });
        },
        json: (obj) => {
            res.setHeader("content-type", "application/json");
            const seen = new WeakSet();
            res.end(JSON.stringify(obj, (_, value) => {
                if (typeof value === "object" && value !== null) {
                    if (seen.has(value)) {
                        return;
                    }
                    seen.add(value);
                }
                return value;
            }));
        },
        redirect: (arg1, arg2) => {
            // Support two overloads:
            // - redirect(url: string): void;
            // - redirect(status: number, url: string): void;
            let code;
            let url;
            if (typeof arg1 === "string") {
                code = 302;
                url = arg1;
            }
            else {
                code = arg1;
                url = arg2;
            }
            res.status(code);
            res.setHeader("Location", url);
            res.end();
        },
    };
    return [req, res];
}
/**
 * @deprecated HttpEndpoint has been renamed to API
 */
exports.HttpEndpoint = API; // tslint:disable-line
//# sourceMappingURL=api.js.map